tada -- templated automatic differentiation
-------------------------------------------


quick install
-------------
  $ git clone http://github.com/quantumelixir/tada
  $ cd tada
  $ mkdir build
  $ cd build
  $ cmake ..
  $ make
  $ ls demos/ tests/


about
-----
tada is an Automatic Differentiation engine written in C++ with a focus on
support for arbitrary types through templates.

Currently, it has native support for:

  * floats (32-bit)
  * doubles (64-bit)
  * mpfr::mpreal (GNU MP multiprecision types with correct rounding semantics)
  * complex (std::complex from the C++ standard)

The idea is to not limit, in any way, the generality of the simplest scalar
types. The data types themselves are decoupled from the actual forward mode
differentiation algorithms through templated univariate taylor propagation.
Automatic differentiation in the forward mode has been implemented through
operator overloading. Plans for implementing lazy evaluation using expression
templates for high performance, expression-specific code are around the corner.

Interval arithmetic also allows for automatic validation of numerical results
through computer generated error bounds. Support for interval arithmetic is
expected to be implemented through MPFI.


current
-------
As of now, tada can differentiate (upto any order) basic arithmetic operations,
elementary functions and trigonometric, hyperbolic functions and their inverses.
Operator overloading yields a very high level of abstraction in specifying the
function to be differentiated.

An example from the set of standard demos included:
sin(x*x)/(1 + log(x)) + asin(1/(1 + cosh(x)*tanh(x)))


testing
-------
All features currently in tada are continually tested using the unit testing
framework CPPUnit. The values encoded in the unit tests (against which our
results are compared) are themselves derived from the symbolic differentiation
program SymPy.


done
----
  * forward mode through univariate taylor propagation (operator overloading)
  * arbitrary precision arithmetic


future
------
  * utp for matrices
  * interval arithmetic
  * solving ordinary differential equations
  * forward and reverse mode using the recorded computational graph
  * discover redundancies in computational graph and reuse common subexpressions
  * interface contraction (hybrid of forward and reverse) on the graph
  * sparse jacobian and hessian matrices through graph coloring
  * arbitrary order differentiation for multivariate functions
  * expression templates (single pass & no temporaries) using PETE/Daixtrose
  * parallel taylor propagation (OpenMP)
  * finite difference methods, richardson's extrapolation (for comparison)


libraries
---------
  * MPFR/GMP: Arbitrary precision arithmetic
  * CPPUnit: Test driven development
